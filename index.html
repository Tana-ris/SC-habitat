<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>What Factors Determine Sasakia charonda Habitat?</title>

  <!-- Leaflet -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <!-- GeoPackage (browser) -->
  <script src="https://unpkg.com/@ngageoint/geopackage@4.2.6/dist/geopackage.min.js"></script>
  <!-- Leaflet GeoPackage plugin (load layers from URL) -->
  <script src="https://unpkg.com/@ngageoint/leaflet-geopackage@4.1.3/dist/leaflet-geopackage.min.js"></script>

  <!-- GeoTIFF / GeoRaster / GeoRasterLayer（推奨の読み込み順） -->
  <script src="https://unpkg.com/geotiff/dist/geotiff.min.js"></script>
  <!-- georaster は UMD 版を指定（グローバルに parser を公開） -->
  <script src="https://unpkg.com/georaster/dist/georaster.browser.min.js"></script>
  <script src="https://unpkg.com/georaster-layer-for-leaflet/dist/georaster-layer-for-leaflet.min.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; width: 100%; }

    /* ===== Layers control (top-left) ===== */
    .leaflet-control-layers {
      font-size: clamp(14px, 1.6vw, 18px);
      transition: transform .15s ease, opacity .15s ease;
    }
    .leaflet-control-layers-expanded {
      max-height: 380px; overflow: auto;
      padding: 10px 12px;
    }
    .leaflet-control-layers label { line-height: 1.4; margin: 4px 0; }
    .leaflet-control-layers input {
      transform: scale(1.2);
      transform-origin: left center;
      margin-right: 6px;
    }
    .leaflet-control-layers-toggle { width: 34px; height: 34px; }

    /* コンパクト化（トグル用） */
    .leaflet-control-layers.is-compact {
      font-size: 12px;
    }
    .leaflet-control-layers.is-compact .leaflet-control-layers-expanded {
      max-height: 180px;
      padding: 6px 8px;
    }
    .leaflet-control-layers.is-compact input {
      transform: scale(1.0);
      margin-right: 4px;
    }

    /* トグルボタン（左上） */
    .ui-toggle.leaflet-control {
      background: rgba(255,255,255,.96);
      padding: 6px 8px; border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,.12);
      font: 13px/1.2 system-ui, sans-serif;
      display: grid; gap: 6px;
    }
    .ui-toggle button {
      cursor: pointer;
      border: 1px solid rgba(0,0,0,.15);
      border-radius: 8px;
      background: #fff;
      padding: 6px 10px;
    }

    /* ===== Legend (bottom-right) ===== */
    .wf-legend.leaflet-control {
      --legend-font-size: clamp(15px, 1.8vw, 20px);
      --legend-line-height: 1.45;
      --legend-swatch: clamp(18px, 2vw, 24px);
      --legend-gap: clamp(8px, 1vw, 12px);

      background: rgba(255,255,255,.96);
      padding: 14px 16px;
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0,0,0,.14);
      font: var(--legend-font-size)/var(--legend-line-height) system-ui, sans-serif;
      font-variant-numeric: tabular-nums;
      min-width: 210px;
      transition: all .15s ease;
    }
    .wf-legend .hdr {
      display: flex; align-items: center; justify-content: space-between;
      gap: 10px; margin: 0 0 10px;
      font-size: calc(var(--legend-font-size) * 1.05); font-weight: 700;
    }
    .wf-legend .btn-legend {
      cursor: pointer;
      border: 1px solid rgba(0,0,0,.15);
      border-radius: 8px; background: #fff; padding: 4px 8px;
      font: 12px/1 system-ui, sans-serif;
    }
    .wf-legend .body {
      display: block;
    }
    .wf-legend .item {
      display: grid;
      grid-template-columns: var(--legend-swatch) 1fr;
      align-items: center;
      gap: var(--legend-gap);
      margin: 6px 0;
    }
    .wf-legend .swatch {
      width: var(--legend-swatch);
      height: var(--legend-swatch);
      border-radius: 4px;
      border: 1px solid rgba(0,0,0,.18);
    }
    .wf-legend .item span:last-child { font-weight: 600; letter-spacing: .01em; }

    /* コンパクト化（凡例） */
    .wf-legend.is-compact {
      --legend-font-size: 13px;
      --legend-swatch: 16px;
      --legend-gap: 6px;
      padding: 10px 12px;
      min-width: 170px;
    }
    .wf-legend.is-collapsed .body { display: none; }

    /* ===== Popup ===== */
    .wf-popup .leaflet-popup-content-wrapper { border-radius: 12px; overflow: hidden; }
    .wf-popup .leaflet-popup-content {
      box-sizing: border-box;
      width: clamp(280px, 60vw, 960px);
      height: clamp(260px, 60vh, 720px);
      margin: 8px 10px; overflow: hidden;
    }
    @supports (height: 100dvh) {
      .wf-popup .leaflet-popup-content { height: clamp(260px, 60dvh, 720px); }
    }
    .wf-pop {
      width: 100%; height: 100%;
      display: flex; flex-direction: column; gap: 8px;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans", sans-serif;
    }
    .wf-prob {
      font-size: clamp(16px, 2vw, 22px);
      line-height: 1.4; font-weight: 700; text-align: center;
      white-space: normal; overflow-wrap: anywhere; word-break: break-word;
      padding: 6px 8px; background: rgba(0,0,0,.03); border-radius: 6px;
    }
    .wf-img-wrap {
      flex: 1 1 auto; min-height: 0;
      display: flex; align-items: center; justify-content: center;
      border: 1px solid rgba(0,0,0,.08); border-radius: 8px; background: #fff;
    }
    .wf-img { width: 100%; height: 100%; object-fit: contain; display: block; }
    .wf-link { margin-top: 2px; font-size: clamp(14px, 1.6vw, 18px); font-weight: 700; text-align: center; }
    .wf-link a { text-decoration: underline; }
    .wf-popup .leaflet-popup-close-button {
      width: 28px; height: 28px; line-height: 28px;
      font-size: 18px; font-weight: 800; color: #fff; background: rgba(0,0,0,.65);
      border-radius: 999px; top: 6px; right: 6px;
    }
    .wf-popup .leaflet-popup-close-button:hover { background: rgba(0,0,0,.8); }

    /* ===== Inset image control (bottom-left) ===== */
    .wf-inset.leaflet-control {
      background: rgba(255,255,255,.96);
      padding: 8px; border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,.12);
    }
    .wf-inset img {
      display: block;
      max-width: clamp(240px, 32vw, 520px);
      max-height: clamp(150px, 32vh, 340px);
      width: auto; height: auto;
    }
    .wf-inset img.is-beeswarm {
      max-width: clamp(300px, 36vw, 600px);
      max-height: clamp(180px, 36vh, 380px);
    }
    .wf-inset .cap { margin-top: 6px; text-align: center; font: 12px/1.3 system-ui, sans-serif; }

    .credits {
      position: absolute; top: 12px; right: 12px; left: auto;
      background: rgba(255,255,255,.9); padding: 6px 8px;
      border-radius: 8px; font: 12px/1.2 system-ui, sans-serif;
      z-index: 500;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="credits">Data: <code>data/Probability_of_occurrence.gpkg</code></div>

  <script>
    (async function () {
      // ===== Paths =====
      const gpkgPointsUrl = 'data/Probability_of_occurrence.gpkg';
      const gpkgStudyUrl  = 'data/Study_area.gpkg';  // polygon (bottom-most overlay)
      const gpkgStreamUrl = 'data/stream.gpkg';      // line (just above polygon)
      const elevUrl       = 'data/Elevation.tif';    // GeoTIFF (raster)

      // i18n (UI is English)
      const I18N = {
        en: { probLabel: 'Probability\u3000of\u3000occurrence', propKey: 'Probability', open: 'Open image in a new tab' },
      };
      const LANG = 'en';

      // GeoPackage init
      const { GeoPackageManager, GeoPackageAPI, setSqljsWasmLocateFile } = window.GeoPackage || {};
      const GPM = GeoPackageManager || GeoPackageAPI;
      if (!GPM || typeof GPM.open !== 'function') {
        console.error('window.GeoPackage keys:', window.GeoPackage && Object.keys(window.GeoPackage));
        throw new Error('Failed to initialize GeoPackage library (GeoPackageManager/GeoPackageAPI missing).');
      }
      setSqljsWasmLocateFile((filename) => `https://unpkg.com/@ngageoint/geopackage@4.2.6/dist/${filename}`);

      // Map init
      const map = L.map('map', { center: [36.07342672630755, 139.35873321947636], zoom: 13 });

      // --- Custom panes to control strict z-order (tiles < raster < study < stream < points) ---
      map.createPane('pane-raster');  map.getPane('pane-raster').style.zIndex  = 305; // below study
      map.createPane('pane-study');   map.getPane('pane-study').style.zIndex   = 310; // bottom-most vector overlay
      map.createPane('pane-streams'); map.getPane('pane-streams').style.zIndex = 320; // above study

      // Basemaps
      const baseLayers = {
        'OpenStreetMap': L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          maxZoom: 19, attribution: '&copy; OpenStreetMap contributors'
        }),
        'GSI Standard Map': L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png', {
          maxZoom: 18, attribution: '&copy; GSI'
        }),
        'GSI Pale': L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/pale/{z}/{x}/{y}.png', {
          maxZoom: 18, attribution: '&copy; GSI'
        }),
        'Esri World Imagery': L.tileLayer(
          'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
          { maxZoom: 19, attribution: 'Tiles &copy; Esri' }
        )
      };
      baseLayers['OpenStreetMap'].addTo(map);

      // Controls
      const overlayLayers = {};
      const layersControl = L.control.layers(baseLayers, overlayLayers, {
        collapsed: false,
        position: 'topleft'
      }).addTo(map);

      // === Layers size toggle (top-left small panel) ===
      const sizeToggle = L.control({ position: 'topleft' });
      sizeToggle.onAdd = function () {
        const div = L.DomUtil.create('div', 'ui-toggle');
        div.innerHTML = `
          <button type="button" id="btn-layers-size" aria-pressed="false" title="Toggle layers size">Layers: Compact</button>
          <button type="button" id="btn-legend-size" aria-pressed="false" title="Toggle legend size">Legend: Compact</button>
          <button type="button" id="btn-legend-collapse" aria-pressed="false" title="Collapse/Expand legend">Legend: Hide</button>
        `;
        L.DomEvent.disableClickPropagation(div);
        return div;
      };
      sizeToggle.addTo(map);

      // Inset image (bottom-left)
      const inset = L.control({ position: 'bottomleft' });
      inset.onAdd = function () {
        const div = L.DomUtil.create('div', 'wf-inset');
        const url = 'data/beeswarm_RF.png';
        div.innerHTML = `
          <img class="is-beeswarm" src="${url}" alt="Beeswarm (Random Forest)"/>
          <div class="cap">Global SHAP (Random Forest)</div>
        `;
        L.DomEvent.disableClickPropagation(div);
        return div;
      };
      inset.addTo(map);

      // ===== Helpers =====
      function getProbAsPercent(props) {
        const cand = ['Probablity','Probability','probability','PROBABILITY','prob','value'];
        let v = null;
        for (const key of cand) {
          if (props && Object.prototype.hasOwnProperty.call(props, key)) { v = Number(props[key]); break; }
        }
        if (!isFinite(v)) return null;
        if (v >= 0 && v <= 1) return v * 100;   // 0–1 -> %
        if (v > 1 && v <= 100) return v;        // 1–100 -> %
        return null;
      }

      // 表示名整形（アンダーバー→スペース、特定名は置換）
      function prettyName(name) {
        if (!name) return 'Layer';
        const lower = String(name).toLowerCase();
        if (lower === 'probability_of_occurrence') return 'Survey site locations';
        return String(name).replace(/_/g, ' ');
      }

      // ==== Color helpers (hex interpolation) ====
      function hexToRgb(hex) {
        const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return m ? { r: parseInt(m[1],16), g: parseInt(m[2],16), b: parseInt(m[3],16) } : {r:0,g:0,b:0};
      }
      function rgbToHex(r,g,b) {
        const toHex = (v)=> ('0'+v.toString(16)).slice(-2);
        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
      }
      function lerp(a,b,t){ return a+(b-a)*t; }
      function lerpColor(c1,c2,t){
        const A=hexToRgb(c1), B=hexToRgb(c2);
        return rgbToHex(Math.round(lerp(A.r,B.r,t)), Math.round(lerp(A.g,B.g,t)), Math.round(lerp(A.b,B.b,t)));
      }

      // ===== Points color ramp =====
      const colorBelow = '#eeeeee';  // <10
      const colorAbove = '#4a1486';  // >80
      const ramp = ['#fff7ec','#fee8c8','#fdd49e','#fdbb84','#fc8d59','#ef6548','#d7301f']; // 10–80
      function colorForPercent(p) {
        if (p == null) return '#9e9e9e';
        if (p < 10)  return colorBelow;
        if (p <= 20) return ramp[0];
        if (p <= 30) return ramp[1];
        if (p <= 40) return ramp[2];
        if (p <= 50) return ramp[3];
        if (p <= 60) return ramp[4];
        if (p <= 70) return ramp[5];
        if (p <= 80) return ramp[6];
        return colorAbove;
      }

      const t = I18N[LANG];
      const formatProbabilityText = (v) => (v == null ? '—' : (v.toFixed(1) + '%'));
      const buildPngPopupHtml = (probText, url, id) => `
        <div class="wf-pop">
          <div class="wf-prob">${t.probLabel} (<code>${t.propKey}</code>): <strong>${probText}</strong></div>
          <div class="wf-link"><a target="_blank" rel="noopener noreferrer" href="${url}">${t.open}</a></div>
          <div class="wf-img-wrap">
            <img class="wf-img" decoding="async" loading="lazy" src="${url}" alt="waterfall_ID${id}_RF" />
          </div>
        </div>
      `;

      async function handleWaterfallClick(feature, ev) {
        const props = (feature && feature.properties) || {};
        const id = props.ID ?? props.id ?? props.Id;
        const p = getProbAsPercent(props);
        const probText = formatProbabilityText(p);

        const popup = L.popup({
          maxWidth: Math.min(960, Math.floor(window.innerWidth * 0.9)),
          className: 'wf-popup',
          autoPan: true, keepInView: true, autoPanPadding: [30, 30]
        }).setLatLng(ev.latlng).setContent('Loading...').openOn(map);

        if (id == null) { popup.setContent('This point has no ID attribute.'); return; }

        const url = `data/waterfall/waterfall_ID${id}_RF.png`;
        const img = new Image();
        img.onload = () => { popup.setContent(buildPngPopupHtml(probText, url, id)); };
        img.onerror = () => { popup.setContent(`File not found: <code>${url}</code>`); };
        img.src = url;
      }

      // ===== Elevation (GeoTIFF raster) =====
      try {
        const elevResp = await fetch(elevUrl);
        if (!elevResp.ok) throw new Error(`Failed to fetch ${elevUrl}: ${elevResp.status} ${elevResp.statusText}`);
        const elevBuf = await elevResp.arrayBuffer();

        // georaster の parser を安全に取得（ビルド差異に対応）
        const parse =
          (typeof window.parseGeoraster === 'function' && window.parseGeoraster) ||
          (typeof window.parseGeoRaster === 'function' && window.parseGeoRaster);

        if (typeof parse !== 'function') {
          throw new ReferenceError('Georaster parser not found. Check georaster script tag.');
        }

        const georaster = await parse(elevBuf);

        const min = (georaster.mins && georaster.mins[0]) ?? 0;
        const max = (georaster.maxs && georaster.maxs[0]) ?? (min + 1);

        // ★ 自然な地形風パレット（低地: 濃緑 → 明緑 → 黄土 → 褐色 → 岩稜灰 → 雪白）
        //   正規化 t ∈ [0,1] に対するカラー停止点
        const stops = [
          { t: 0.00, c: '#00441b' }, // deep green
          { t: 0.15, c: '#1b7837' },
          { t: 0.30, c: '#5aae61' },
          { t: 0.50, c: '#a6d96a' },
          { t: 0.70, c: '#dfc27d' }, // tan
          { t: 0.85, c: '#a6611a' }, // brown
          { t: 0.94, c: '#cfcfcf' }, // gray
          { t: 1.00, c: '#ffffff' }  // snow
        ];
        function colorForElev(v) {
          if (v == null || !isFinite(v)) return null;
          const t = Math.max(0, Math.min(1, (v - min) / (max - min)));
          // 区間を探して線形補間
          for (let i=0; i<stops.length-1; i++) {
            const a = stops[i], b = stops[i+1];
            if (t >= a.t && t <= b.t) {
              const tt = (t - a.t) / (b.t - a.t || 1e-6);
              return lerpColor(a.c, b.c, tt);
            }
          }
          return stops[stops.length-1].c;
        }

        const elevationLayer = new GeoRasterLayer({
          georaster,
          pane: 'pane-raster',
          opacity: 0.65,
          resolution: 256,
          pixelValuesToColorFn: values => colorForElev(values[0])
        }).addTo(map);

        overlayLayers['Elevation'] = elevationLayer;
        layersControl.addOverlay(elevationLayer, 'Elevation');
      } catch (e) {
        console.warn('Skipping Elevation.tif loading:', e);
      }

      // ===== Load Study Area (polygon) as bottom-most overlay =====
      async function addSimpleVectorGpkg(url, paneName, layerLabel, styleObj) {
        const resp = await fetch(url);
        if (!resp.ok) throw new Error(`Failed to fetch ${url}: ${resp.status} ${resp.statusText}`);
        const buf = await resp.arrayBuffer();
        const gpkg = await GPM.open(new Uint8Array(buf));
        const tables = gpkg.getFeatureTables();
        if (!tables || !tables.length) { gpkg.close(); throw new Error(`No feature layers found in ${url}`); }

        const group = L.layerGroup();
        for (const tableName of tables) {
          const lyr = L.geoPackageFeatureLayer([], {
            geoPackageUrl: url,
            layerName: tableName,
            pane: paneName,
            interactive: false,
            style: typeof styleObj === 'function' ? styleObj : () => styleObj
          });
          group.addLayer(lyr);
        }
        group.addTo(map);
        overlayLayers[layerLabel] = group;
        layersControl.addOverlay(group, layerLabel);
        gpkg.close();
      }

      // ★ Study area：塗りを消し、境界線を太く
      await addSimpleVectorGpkg(
        gpkgStudyUrl,
        'pane-study',
        'Study area',
        { color: '#263238', weight: 3.8, fillOpacity: 0, fill: false }
      );

      // Streams line style (blue, above polygon)
      await addSimpleVectorGpkg(
        gpkgStreamUrl,
        'pane-streams',
        'Streams',
        { color: '#1e88e5', weight: 2, opacity: 0.95 }
      );

      // ===== Load points (on top) =====
      const respPts = await fetch(gpkgPointsUrl);
      if (!respPts.ok) throw new Error(`Failed to fetch GPKG: ${respPts.status} ${respPts.statusText}`);
      const arrayBufPts = await respPts.arrayBuffer();
      const gpkgPts = await GPM.open(new Uint8Array(arrayBufPts));
      const featureTablesPts = gpkgPts.getFeatureTables();
      if (!featureTablesPts || featureTablesPts.length === 0) throw new Error('No feature layers were found in the points GeoPackage.');

      for (const tableName of featureTablesPts) {
        const layer = L.geoPackageFeatureLayer([], {
          geoPackageUrl: gpkgPointsUrl,
          layerName: tableName,
          pointToLayer: (feature, latlng) => {
            const p = getProbAsPercent(feature.properties);
            return L.circleMarker(latlng, {
              radius: 8,
              weight: 2,
              opacity: 1,
              color: '#ffffff',
              fillOpacity: 0.9,
              fillColor: colorForPercent(p),
              className: 'wf-point'
            });
          },
          onEachFeature: (feature, lyr) => {
            lyr.setStyle({ color: '#ffffff' });
            lyr.on('click', (ev) => handleWaterfallClick(feature, ev));
          }
        }).addTo(map);

        const displayName = prettyName(tableName);
        overlayLayers[displayName] = layer;
        layersControl.addOverlay(layer, displayName);
      }

      // ===== Legend =====
      const legend = L.control({ position: 'bottomright' });
      legend.onAdd = function () {
        const div = L.DomUtil.create('div', 'wf-legend');
        div.innerHTML = `
          <div class="hdr">
            <span>Probability of occurrence (%)</span>
            <div>
              <button type="button" class="btn-legend" data-act="compact" aria-pressed="false" title="Toggle compact">Compact</button>
              <button type="button" class="btn-legend" data-act="collapse" aria-pressed="false" title="Hide/show">Hide</button>
            </div>
          </div>
          <div class="body">
            <div class="item"><span class="swatch" style="background:${colorBelow}"></span><span>&lt; 10</span></div>
            <div class="item"><span class="swatch" style="background:${ramp[0]}"></span><span>10–20</span></div>
            <div class="item"><span class="swatch" style="background:${ramp[1]}"></span><span>20–30</span></div>
            <div class="item"><span class="swatch" style="background:${ramp[2]}"></span><span>30–40</span></div>
            <div class="item"><span class="swatch" style="background:${ramp[3]}"></span><span>40–50</span></div>
            <div class="item"><span class="swatch" style="background:${ramp[4]}"></span><span>50–60</span></div>
            <div class="item"><span class="swatch" style="background:${ramp[5]}"></span><span>60–70</span></div>
            <div class="item"><span class="swatch" style="background:${ramp[6]}"></span><span>70–80</span></div>
            <div class="item"><span class="swatch" style="background:${colorAbove}"></span><span>&gt; 80</span></div>
          </div>
        `;
        L.DomEvent.disableClickPropagation(div);
        return div;
      };
      legend.addTo(map);

      // === Wire up toggles ===
      const lc = layersControl.getContainer();
      const lg = legend.getContainer();

      // 左上のボタン：Layers Compact
      document.getElementById('btn-layers-size').addEventListener('click', (e) => {
        const pressed = lc.classList.toggle('is-compact');
        e.currentTarget.setAttribute('aria-pressed', String(pressed));
        e.currentTarget.textContent = pressed ? 'Layers: Normal' : 'Layers: Compact';
      });

      // 左上のボタン：Legend Compact
      document.getElementById('btn-legend-size').addEventListener('click', (e) => {
        const pressed = lg.classList.toggle('is-compact');
        e.currentTarget.setAttribute('aria-pressed', String(pressed));
        e.currentTarget.textContent = pressed ? 'Legend: Normal' : 'Legend: Compact';
      });

      // 左上のボタン：Legend Hide/Show（本文完全折畳み）
      document.getElementById('btn-legend-collapse').addEventListener('click', (e) => {
        const pressed = lg.classList.toggle('is-collapsed');
        e.currentTarget.setAttribute('aria-pressed', String(pressed));
        e.currentTarget.textContent = pressed ? 'Legend: Show' : 'Legend: Hide';
      });

      // 凡例内のボタン（同機能）
      lg.querySelectorAll('.btn-legend').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const act = e.currentTarget.getAttribute('data-act');
          if (act === 'compact') {
            const pressed = lg.classList.toggle('is-compact');
            e.currentTarget.setAttribute('aria-pressed', String(pressed));
            e.currentTarget.textContent = pressed ? 'Normal' : 'Compact';
          } else if (act === 'collapse') {
            const pressed = lg.classList.toggle('is-collapsed');
            e.currentTarget.setAttribute('aria-pressed', String(pressed));
            e.currentTarget.textContent = pressed ? 'Show' : 'Hide';
          }
        });
      });

      gpkgPts.close();
    })().catch((err) => {
      console.error(err);
      alert('An error occurred while loading. See console for details.\n' + err.message);
    });
  </script>
</body>
</html>
