<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sasakia charonda Habitat Suitability - Namegawa Town</title>
  <meta name="description" content="Interactive visualization of machine learning-based habitat suitability assessment for Sasakia charonda">

  <!-- Leaflet -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <!-- GeoPackage -->
  <script src="https://unpkg.com/@ngageoint/geopackage@4.2.6/dist/geopackage.min.js"></script>
  <script src="https://unpkg.com/@ngageoint/leaflet-geopackage@4.1.3/dist/leaflet-geopackage.min.js"></script>

  <style>
    html, body { 
      height: 100%; 
      margin: 0; 
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; 
    }
    #map { 
      height: 100%; 
      width: 100%; 
      background: #f0f4f7; 
    }

    /* ===== Model Info Badge (ÊüªË™≠ËÄÖÂêë„Åë) ===== */
    .model-badge {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.95);
      padding: 8px 12px;
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      z-index: 1000;
      font-size: 11px;
      display: flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .model-badge:hover {
      box-shadow: 0 3px 10px rgba(0,0,0,0.15);
      transform: translateY(-1px);
    }
    .model-badge .model-name {
      font-weight: 700;
      color: #2c3e50;
    }
    .model-badge .model-metric {
      background: #27ae60;
      color: white;
      padding: 2px 6px;
      border-radius: 3px;
      font-weight: 600;
    }
    .model-badge .info-icon {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: #3498db;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: bold;
    }
    
    /* Model details popup */
    .model-details {
      display: none;
      position: absolute;
      top: 100%;
      right: 0;
      margin-top: 5px;
      background: white;
      border: 1px solid #e1e4e8;
      border-radius: 6px;
      padding: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      width: 280px;
      font-size: 11px;
      z-index: 1001;
    }
    .model-badge:hover .model-details {
      display: block;
    }
    .model-details h5 {
      margin: 0 0 8px;
      font-size: 12px;
      color: #2c3e50;
      border-bottom: 1px solid #e1e4e8;
      padding-bottom: 4px;
    }
    .model-details .detail-row {
      margin: 4px 0;
      display: flex;
      justify-content: space-between;
    }
    .model-details .detail-label {
      color: #5a6c7d;
    }
    .model-details .detail-value {
      font-weight: 600;
      color: #2c3e50;
    }
    .model-details .threshold-info {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid #e1e4e8;
      color: #5a6c7d;
    }

    /* ===== Layers control (Â∑¶‰∏ä) - „Ç∑„É≥„Éó„É´Âåñ ===== */
    .leaflet-control-layers {
      font-size: 14px;
      transition: all .2s ease;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.95);
    }
    .leaflet-control-layers-expanded {
      padding: 10px 14px 10px 10px;
      min-width: 150px;
    }
    .leaflet-control-layers-base,
    .leaflet-control-layers-overlays {
      margin: 5px 0;
    }
    .leaflet-control-layers label { 
      display: flex;
      align-items: center;
      margin: 4px 0;
      cursor: pointer;
    }
    .leaflet-control-layers input[type="radio"],
    .leaflet-control-layers input[type="checkbox"] {
      margin: 0 8px 0 0;
    }

    /* ÊúÄÂ∞èÂåñ„Éú„Çø„É≥ */
    .minimize-btn {
      position: absolute; 
      top: 8px; 
      right: 8px;
      width: 20px; 
      height: 20px;
      border: 1px solid #d0d0d0;
      border-radius: 3px; 
      background: #fff; 
      cursor: pointer;
      font: 14px/18px Arial, sans-serif;
      color: #666;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all .15s;
      z-index: 1;
    }
    .minimize-btn:hover { 
      background: #f4f4f4; 
      border-color: #999;
    }
    .is-minimized .leaflet-control-layers-list { display: none !important; }

    /* ===== Áµ±Ë®à„Éë„Éç„É´ („Éá„Çπ„ÇØ„Éà„ÉÉ„Éó„ÅÆ„Åø) ===== */
    .stats-panel.leaflet-control {
      background: rgba(255, 255, 255, 0.95);
      padding: 10px 14px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      font-size: 12px;
      min-width: 180px;
    }
    .stats-panel h4 {
      margin: 0 0 8px;
      font-size: 13px;
      font-weight: 600;
      color: #2c3e50;
      padding-bottom: 4px;
      border-bottom: 1px solid #e1e4e8;
    }
    .stats-item {
      display: flex;
      justify-content: space-between;
      margin: 4px 0;
    }
    .stats-label {
      color: #5a6c7d;
      font-size: 11px;
    }
    .stats-value {
      font-weight: 600;
      color: #2c3e50;
      font-size: 11px;
    }

    /* ===== „Éï„Ç£„É´„Çø„Éº„Éë„Éç„É´ („Éá„Çπ„ÇØ„Éà„ÉÉ„Éó„ÅÆ„Åø) ===== */
    .filter-panel.leaflet-control {
      background: rgba(255, 255, 255, 0.95);
      padding: 10px 14px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      min-width: 200px;
    }
    .filter-header {
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 8px;
      color: #2c3e50;
      padding-bottom: 4px;
      border-bottom: 1px solid #e1e4e8;
    }
    .filter-range {
      margin: 8px 0;
    }
    .filter-range label {
      display: block;
      font-size: 11px;
      color: #5a6c7d;
      margin-bottom: 3px;
    }
    .filter-slider {
      width: 100%;
      margin: 5px 0;
      cursor: pointer;
    }
    .filter-value {
      text-align: center;
      font-weight: 600;
      font-size: 11px;
      color: #2c3e50;
      padding: 3px;
      background: #f6f8fa;
      border-radius: 3px;
      margin-top: 3px;
    }
    .filter-reset {
      width: 100%;
      padding: 5px;
      margin-top: 6px;
      background: #0366d6;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      font-size: 11px;
      font-weight: 600;
      transition: background .15s;
    }
    .filter-reset:hover { background: #0256c7; }
    .filter-reset:active { transform: translateY(1px); }

    /* ===== Legend (Âè≥‰∏ã) ===== */
    .wf-legend.leaflet-control {
      background: rgba(255, 255, 255, 0.95);
      padding: 10px 12px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      font-size: 12px;
      min-width: 160px;
    }
    .wf-legend .hdr {
      display: flex; 
      align-items: center; 
      justify-content: space-between;
      margin: 0 0 8px; 
      font-weight: 600;
      font-size: 13px;
      color: #2c3e50;
      padding-bottom: 4px;
      border-bottom: 1px solid #e1e4e8;
    }
    .wf-legend .body { 
      display: block; 
    }
    .wf-legend .item {
      display: grid; 
      grid-template-columns: 18px 1fr;
      align-items: center; 
      gap: 8px; 
      margin: 4px 0;
    }
    .wf-legend .swatch {
      width: 18px; 
      height: 18px;
      border-radius: 2px; 
      border: 1px solid rgba(0,0,0,.15);
    }
    .wf-legend .item span:last-child { 
      font-size: 11px;
      color: #2c3e50;
    }
    .wf-legend.is-minimized .body { display: none; }

    /* ===== Popup ===== */
    .wf-popup .leaflet-popup-content-wrapper { 
      border-radius: 8px; 
      overflow: hidden;
    }
    .wf-popup .leaflet-popup-content {
      box-sizing: border-box; 
      width: clamp(280px, 45vw, 600px);
      height: clamp(260px, 45vh, 500px); 
      margin: 8px; 
      overflow: hidden;
    }
    .wf-pop { 
      width: 100%; 
      height: 100%; 
      display: flex; 
      flex-direction: column; 
      gap: 8px;
    }
    .wf-prob { 
      font-size: 14px; 
      font-weight: 600; 
      text-align: center;
      padding: 6px; 
      background: #f6f8fa; 
      border-radius: 4px;
      color: #2c3e50;
    }
    .wf-img-wrap { 
      flex: 1 1 auto; 
      min-height: 0; 
      display: flex; 
      align-items: center; 
      justify-content: center;
      border: 1px solid #e1e4e8; 
      border-radius: 4px; 
      background: #fff;
    }
    .wf-img { 
      width: 100%; 
      height: 100%; 
      object-fit: contain; 
      display: block;
    }
    .wf-link { 
      font-size: 11px; 
      text-align: center;
    }
    .wf-link a { 
      color: #0366d6;
      text-decoration: none;
    }
    .wf-link a:hover { text-decoration: underline; }

    /* ===== Inset Beeswarm ===== */
    .wf-inset.leaflet-control {
      background: rgba(255,255,255,.95); 
      padding: 6px; 
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,.1);
    }
    .wf-inset img { 
      display: block; 
      max-width: clamp(300px, 36vw, 600px); 
      max-height: clamp(180px, 36vh, 380px);
    }
    .wf-inset img.is-beeswarm {
      max-width: clamp(320px, 38vw, 620px);
      max-height: clamp(200px, 38vh, 400px);
    }
    .wf-inset .cap { 
      margin-top: 4px; 
      text-align: center; 
      font-size: 10px;
      color: #5a6c7d;
      font-weight: 600;
    }

    /* ===== Data Export Button (ÊüªË™≠ËÄÖÂêë„Åë) ===== */
    .export-btn.leaflet-control {
      background: rgba(255, 255, 255, 0.95);
      padding: 6px 10px;
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      cursor: pointer;
      transition: all 0.2s;
    }
    .export-btn:hover {
      background: #fff;
      box-shadow: 0 3px 8px rgba(0,0,0,0.15);
    }
    .export-btn button {
      background: #0366d6;
      color: white;
      border: none;
      padding: 4px 12px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .export-btn button:hover {
      background: #0256c7;
    }
    .export-btn button:active {
      transform: translateY(1px);
    }
    
    /* ===== Key findings annotation (ÊüªË™≠ËÄÖÂêë„Åë) ===== */
    .key-findings.leaflet-control {
      background: rgba(255, 255, 255, 0.95);
      padding: 8px 10px;
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      font-size: 11px;
      max-width: 250px;
      border-left: 3px solid #e74c3c;
    }
    .key-findings h5 {
      margin: 0 0 6px;
      font-size: 12px;
      font-weight: 600;
      color: #e74c3c;
    }
    .key-findings ul {
      margin: 0;
      padding-left: 18px;
      color: #2c3e50;
      line-height: 1.4;
    }
    .key-findings li {
      margin: 3px 0;
    }
    
    /* ===== „Éù„Ç§„É≥„Éà ===== */
    .wf-point { 
      cursor: pointer;
    }

    /* ===== Tooltip ===== */
    .leaflet-tooltip {
      font-size: 11px;
      font-weight: 600;
      padding: 4px 8px;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #d0d0d0;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    /* ===== „É¢„Éê„Ç§„É´ÂØæÂøú ===== */
    @media (max-width: 768px) {
      /* Model badge, key findings, export btn„Çí„É¢„Éê„Ç§„É´„ÅßÈùûË°®Á§∫ */
      .model-badge,
      .key-findings,
      .export-btn {
        display: none;
      }
      
      /* „É¢„Éê„Ç§„É´„Åß„ÅØÁµ±Ë®à„Å®„Éï„Ç£„É´„Çø„Éº„Éë„Éç„É´„ÇíÈùûË°®Á§∫ */
      .stats-panel, .filter-panel {
        display: none !important;
      }
      
      /* „É¢„Éê„Ç§„É´„Åß„ÅØ„ÉÑ„Éº„É´„ÉÅ„ÉÉ„Éó„ÇÇÈùûË°®Á§∫ */
      .leaflet-tooltip {
        display: none !important;
      }
      
      .leaflet-control-layers {
        font-size: 13px;
      }
      .leaflet-control-layers-expanded {
        padding: 8px 12px 8px 8px;
      }
      
      .wf-legend {
        font-size: 11px;
        padding: 8px 10px;
        min-width: 140px;
      }
      .wf-legend .hdr {
        font-size: 12px;
      }
      .wf-legend .item {
        grid-template-columns: 16px 1fr;
        gap: 6px;
      }
      .wf-legend .swatch {
        width: 16px;
        height: 16px;
      }
      
      .wf-popup .leaflet-popup-content {
        width: 85vw;
        height: 50vh;
      }
      
      .wf-inset img {
        max-width: clamp(240px, 32vw, 400px);
        max-height: clamp(150px, 32vh, 250px);
      }
      .wf-inset img.is-beeswarm {
        max-width: clamp(260px, 34vw, 420px);
        max-height: clamp(160px, 34vh, 260px);
      }
      
      .minimize-btn {
        width: 24px;
        height: 24px;
        font-size: 16px;
      }
    }

    @media (max-width: 480px) {
      .wf-legend {
        bottom: 60px;
      }
      .wf-inset {
        max-width: 220px;
      }
      .wf-inset img {
        max-width: 210px;
        max-height: 130px;
      }
      .wf-inset img.is-beeswarm {
        max-width: 220px;
        max-height: 140px;
      }
    }
  </style>
</head>
<body>
  <div id="map"></div>
  
  <!-- Model Performance Badge (ÊüªË™≠ËÄÖÂêë„Åë) -->
  <div class="model-badge">
    <span class="model-name">Random Forest</span>
    <span class="model-metric">AUC 0.720</span>
    <span class="info-icon">i</span>
    <div class="model-details">
      <h5>Model Performance & Methods</h5>
      <div class="detail-row">
        <span class="detail-label">Cross-validation:</span>
        <span class="detail-value">Spatial Group K-fold</span>
      </div>
      <div class="detail-row">
        <span class="detail-label">Imbalance handling:</span>
        <span class="detail-value">SMOTE</span>
      </div>
      <div class="detail-row">
        <span class="detail-label">Feature importance:</span>
        <span class="detail-value">SHAP values</span>
      </div>
      <div class="detail-row">
        <span class="detail-label">Sample size:</span>
        <span class="detail-value">n = 144 points</span>
      </div>
      <div class="threshold-info">
        <strong>Key thresholds:</strong><br>
        ‚Ä¢ Litter depth ‚â• 5 cm<br>
        ‚Ä¢ DBH ‚â• 40 cm<br>
        ‚Ä¢ Vegetation cover ‚â• 40%
      </div>
    </div>
  </div>

  <script>
    (async function () {
      // ===== Configuration =====
      const CONFIG = {
        gpkgPointsUrl: 'data/Probability_of_occurrence.gpkg',
        gpkgStudyUrl: 'data/Study_area.gpkg',
        gpkgStreamUrl: 'data/stream.gpkg',
        waterfallBaseUrl: 'data/waterfall/',
        
        // Visual parameters  
        pointStroke: '#34495e',      // ÊøÉ„ÅÑ„Ç∞„É¨„Éº
        pointStrokeWidth: 1.5,
        pointStrokeOpacity: 0.9,
        pointBaseRadius: 7,
        pointHoverRadius: 9,
        
        // Mobile detection
        isMobile: window.innerWidth <= 768
      };

      // ===== ColorBrewer 9ÊÆµÈöé (YlOrRd scheme) =====
      const COLOR_SCHEME = {
        below10: '#ffffcc',     // Very light yellow
        range10_20: '#ffeda0',  // Light yellow
        range20_30: '#fed976',  // Yellow
        range30_40: '#feb24c',  // Light orange
        range40_50: '#fd8d3c',  // Orange
        range50_60: '#fc4e2a',  // Dark orange
        range60_70: '#e31a1c',  // Red-orange
        range70_80: '#bd0026',  // Red
        above80: '#800026'      // Dark red
      };

      function colorForPercent(p) {
        if (p == null) return '#bdbdbd';
        if (p < 10) return COLOR_SCHEME.below10;
        if (p <= 20) return COLOR_SCHEME.range10_20;
        if (p <= 30) return COLOR_SCHEME.range20_30;
        if (p <= 40) return COLOR_SCHEME.range30_40;
        if (p <= 50) return COLOR_SCHEME.range40_50;
        if (p <= 60) return COLOR_SCHEME.range50_60;
        if (p <= 70) return COLOR_SCHEME.range60_70;
        if (p <= 80) return COLOR_SCHEME.range70_80;
        return COLOR_SCHEME.above80;
      }

      // ===== GeoPackage initialization =====
      const { GeoPackageManager, GeoPackageAPI, setSqljsWasmLocateFile } = window.GeoPackage || {};
      const GPM = GeoPackageManager || GeoPackageAPI;
      if (!GPM || typeof GPM.open !== 'function') {
        throw new Error('Failed to initialize GeoPackage library.');
      }
      setSqljsWasmLocateFile((filename) => 
        `https://unpkg.com/@ngageoint/geopackage@4.2.6/dist/${filename}`
      );

      // ===== Map initialization =====
      const map = L.map('map', {
        center: [36.07342672630755, 139.35873321947636],
        zoom: 13,
        zoomControl: true,
        attributionControl: true
      });

      // Create panes
      map.createPane('pane-study');
      map.createPane('pane-streams');
      map.createPane('pane-points');
      map.getPane('pane-study').style.zIndex = 310;
      map.getPane('pane-streams').style.zIndex = 320;
      map.getPane('pane-points').style.zIndex = 330;

      // ===== Base layers =====
      const baseLayers = {
        'OpenStreetMap': L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          maxZoom: 19,
          attribution: '¬© OpenStreetMap'
        }),
        'GSI Standard': L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png', {
          maxZoom: 18,
          attribution: '¬© GSI Japan'
        }),
        'GSI Pale': L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/pale/{z}/{x}/{y}.png', {
          maxZoom: 18,
          attribution: '¬© GSI Japan'
        }),
        'Satellite': L.tileLayer(
          'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
          { maxZoom: 19, attribution: '¬© Esri' }
        )
      };
      baseLayers['OpenStreetMap'].addTo(map);

      // Scale control
      L.control.scale({ 
        position: 'bottomleft', 
        metric: true, 
        imperial: false, 
        maxWidth: 100 
      }).addTo(map);

      // ===== Layers control with minimize =====
      const overlayLayers = {};
      const layersControl = L.control.layers(baseLayers, overlayLayers, { 
        collapsed: false, 
        position: 'topleft' 
      }).addTo(map);

      const lc = layersControl.getContainer();
      const lcMinBtn = L.DomUtil.create('button', 'minimize-btn', lc);
      lcMinBtn.innerHTML = '‚àí';
      lcMinBtn.title = 'Minimize';
      L.DomEvent.on(lcMinBtn, 'click', (e) => {
        L.DomEvent.stop(e);
        lc.classList.toggle('is-minimized');
        lcMinBtn.innerHTML = lc.classList.contains('is-minimized') ? '+' : '‚àí';
      });

      // ===== Statistics Panel („Éá„Çπ„ÇØ„Éà„ÉÉ„Éó„ÅÆ„Åø) =====
      let allPoints = [];
      if (!CONFIG.isMobile) {
        const statsControl = L.control({ position: 'topright' });
        statsControl.onAdd = function() {
          const div = L.DomUtil.create('div', 'stats-panel leaflet-control');
          div.innerHTML = `
            <h4>Statistics</h4>
            <div class="stats-item">
              <span class="stats-label">Total Points:</span>
              <span class="stats-value" id="totalPoints">0</span>
            </div>
            <div class="stats-item">
              <span class="stats-label">Visible:</span>
              <span class="stats-value" id="visiblePoints">0</span>
            </div>
            <div class="stats-item">
              <span class="stats-label">Mean Prob.:</span>
              <span class="stats-value" id="meanProb">‚Äî</span>
            </div>
            <div class="stats-item">
              <span class="stats-label">Max Prob.:</span>
              <span class="stats-value" id="maxProb">‚Äî</span>
            </div>
            <div class="stats-item">
              <span class="stats-label">High (>60%):</span>
              <span class="stats-value" id="highCount">0</span>
            </div>
            <div class="stats-item">
              <span class="stats-label">Med (30-60%):</span>
              <span class="stats-value" id="midCount">0</span>
            </div>
            <div class="stats-item">
              <span class="stats-label">Low (<30%):</span>
              <span class="stats-value" id="lowCount">0</span>
            </div>
          `;
          L.DomEvent.disableClickPropagation(div);
          return div;
        };
        statsControl.addTo(map);
      }

      function updateStatistics(points) {
        if (CONFIG.isMobile) return;
        const total = points.length;
        const probs = points.map(p => p.probability).filter(p => p != null);
        if (probs.length > 0) {
          const mean = probs.reduce((a, b) => a + b, 0) / probs.length;
          const max = Math.max(...probs);
          const high = probs.filter(p => p > 60).length;
          const mid = probs.filter(p => p >= 30 && p <= 60).length;
          const low = probs.filter(p => p < 30).length;
          document.getElementById('totalPoints').textContent = total;
          document.getElementById('visiblePoints').textContent = probs.length;
          document.getElementById('meanProb').textContent = mean.toFixed(1) + '%';
          document.getElementById('maxProb').textContent = max.toFixed(1) + '%';
          document.getElementById('highCount').textContent = high;
          document.getElementById('midCount').textContent = mid;
          document.getElementById('lowCount').textContent = low;
        }
      }

      // ===== Filter Panel („Éá„Çπ„ÇØ„Éà„ÉÉ„Éó„ÅÆ„Åø) =====
      let pointsLayer = null;
      let currentMinProb = 0;
      let currentMaxProb = 100;

      if (!CONFIG.isMobile) {
        const filterControl = L.control({ position: 'topright' });
        filterControl.onAdd = function() {
          const div = L.DomUtil.create('div', 'filter-panel leaflet-control');
          div.innerHTML = `
            <div class="filter-header">Probability Filter</div>
            <div class="filter-range">
              <label>Minimum</label>
              <input type="range" class="filter-slider" id="minProbSlider" 
                     min="0" max="100" value="0" step="5">
              <div class="filter-value" id="minProbValue">‚â• 0%</div>
            </div>
            <div class="filter-range">
              <label>Maximum</label>
              <input type="range" class="filter-slider" id="maxProbSlider" 
                     min="0" max="100" value="100" step="5">
              <div class="filter-value" id="maxProbValue">‚â§ 100%</div>
            </div>
            <button class="filter-reset" id="resetFilter">Reset</button>
          `;
          L.DomEvent.disableClickPropagation(div);
          return div;
        };
        filterControl.addTo(map);

        // Filter event handlers
        setTimeout(() => {
          const minSlider = document.getElementById('minProbSlider');
          const maxSlider = document.getElementById('maxProbSlider');
          const resetBtn = document.getElementById('resetFilter');
          
          if (minSlider) {
            minSlider.addEventListener('input', function(e) {
              currentMinProb = Number(e.target.value);
              document.getElementById('minProbValue').textContent = `‚â• ${currentMinProb}%`;
              applyFilter();
            });
          }
          if (maxSlider) {
            maxSlider.addEventListener('input', function(e) {
              currentMaxProb = Number(e.target.value);
              document.getElementById('maxProbValue').textContent = `‚â§ ${currentMaxProb}%`;
              applyFilter();
            });
          }
          if (resetBtn) {
            resetBtn.addEventListener('click', function() {
              currentMinProb = 0;
              currentMaxProb = 100;
              document.getElementById('minProbSlider').value = 0;
              document.getElementById('maxProbSlider').value = 100;
              document.getElementById('minProbValue').textContent = '‚â• 0%';
              document.getElementById('maxProbValue').textContent = '‚â§ 100%';
              applyFilter();
            });
          }
        }, 100);
      }

      function applyFilter() {
        if (!pointsLayer || CONFIG.isMobile) return;
        const visiblePoints = [];
        pointsLayer.eachLayer(function(layer) {
          const prob = layer.feature.properties.probability || 
                       getProbAsPercent(layer.feature.properties);
          if (prob >= currentMinProb && prob <= currentMaxProb) {
            layer.setStyle({ fillOpacity: 0.85, opacity: 1 });
            visiblePoints.push({ probability: prob });
          } else {
            layer.setStyle({ fillOpacity: 0.1, opacity: 0.3 });
          }
        });
        updateStatistics(visiblePoints);
      }

      // ===== Helper functions =====
      function getProbAsPercent(props) {
        const candidates = ['Probablity', 'Probability', 'probability', 'PROBABILITY', 'prob', 'value'];
        let v = null;
        for (const key of candidates) {
          if (props && Object.prototype.hasOwnProperty.call(props, key)) {
            v = Number(props[key]);
            break;
          }
        }
        if (!isFinite(v)) return null;
        if (v >= 0 && v <= 1) return v * 100;
        if (v > 1 && v <= 100) return v;
        return null;
      }

      function prettyName(name) {
        if (!name) return 'Layer';
        const lower = String(name).toLowerCase();
        if (lower === 'probability_of_occurrence') return 'Probability of Occurrence';
        return String(name).replace(/_/g, ' ');
      }

      async function handleWaterfallClick(feature, ev) {
        const props = (feature && feature.properties) || {};
        const id = props.ID ?? props.id ?? props.Id;
        const p = getProbAsPercent(props);
        const probText = p == null ? '‚Äî' : p.toFixed(1) + '%';
        
        const popup = L.popup({
          maxWidth: Math.min(600, Math.floor(window.innerWidth * 0.85)),
          className: 'wf-popup',
          autoPan: true,
          keepInView: true,
          autoPanPadding: [30, 30]
        }).setLatLng(ev.latlng).setContent('Loading...').openOn(map);
        
        if (id == null) {
          popup.setContent('This point has no ID attribute.');
          return;
        }
        
        const url = `${CONFIG.waterfallBaseUrl}waterfall_ID${id}_RF.png`;
        const img = new Image();
        img.onload = () => {
          popup.setContent(`
            <div class="wf-pop">
              <div class="wf-prob">
                Probability of occurrence: <strong>${probText}</strong>
              </div>
              <div class="wf-shap-info" style="font-size: 12px; color: #7f8c8d; text-align: center; padding: 4px; background: #f8f9fa; border-radius: 4px;">
                SHAP waterfall plot for Random Forest prediction at Point ID ${id}
              </div>
              <div class="wf-img-wrap">
                <img class="wf-img" src="${url}" alt="SHAP waterfall ID${id}"/>
              </div>
              <div class="wf-link">
                <a target="_blank" rel="noopener" href="${url}">Open full image in new tab ‚Üí</a>
              </div>
            </div>
          `);
        };
        img.onerror = () => {
          popup.setContent(`
            <div style="padding: 20px; text-align: center;">
              <p>SHAP visualization not available</p>
              <p style="font-size: 11px; color: #7f8c8d;">File: ${url}</p>
            </div>
          `);
        };
        img.src = url;
      }

      // ===== Load GeoPackage layers (Study area & Streams) =====
      async function addSimpleVectorGpkg(url, paneName, layerLabel, styleObj) {
        const resp = await fetch(url);
        if (!resp.ok) throw new Error(`Failed to fetch ${url}`);
        const buf = await resp.arrayBuffer();
        const gpkg = await GPM.open(new Uint8Array(buf));
        const tables = gpkg.getFeatureTables();
        if (!tables || !tables.length) {
          gpkg.close();
          throw new Error(`No feature layers found in ${url}`);
        }
        const group = L.featureGroup();
        for (const tableName of tables) {
          const lyr = L.geoPackageFeatureLayer([], {
            geoPackageUrl: url,
            layerName: tableName,
            pane: paneName,
            interactive: false,
            style: typeof styleObj === 'function' ? styleObj : () => styleObj
          });
          group.addLayer(lyr);
        }
        group.addTo(map);
        overlayLayers[layerLabel] = group;
        layersControl.addOverlay(group, layerLabel);
        gpkg.close();
        return group;
      }

      // Study Area
      const studyGroup = await addSimpleVectorGpkg(
        CONFIG.gpkgStudyUrl, 'pane-study', 'Study Area',
        { 
          color: '#2c3e50', 
          weight: 2.5, 
          fillOpacity: 0, 
          fill: false,
          dashArray: '8, 4'
        }
      );
      const studyBounds = studyGroup.getBounds();
      if (studyBounds && studyBounds.isValid()) {
        map.fitBounds(studyBounds, { padding: [30, 30] });
      }

      // Streams
      await addSimpleVectorGpkg(
        CONFIG.gpkgStreamUrl, 'pane-streams', 'Streams',
        { 
          color: '#2980b9', 
          weight: 2, 
          opacity: 0.7,
          lineCap: 'round',
          lineJoin: 'round'
        }
      );

      // ===== Load Points (GeoPackage) =====
      const respPts = await fetch(CONFIG.gpkgPointsUrl);
      if (!respPts.ok) throw new Error(`Failed to fetch points GeoPackage`);
      const arrayBufPts = await respPts.arrayBuffer();
      const gpkgPts = await GPM.open(new Uint8Array(arrayBufPts));
      const featureTablesPts = gpkgPts.getFeatureTables();
      if (!featureTablesPts || featureTablesPts.length === 0) {
        throw new Error('No feature layers found in points GeoPackage');
      }

      for (const tableName of featureTablesPts) {
        const layer = L.geoPackageFeatureLayer([], {
          geoPackageUrl: CONFIG.gpkgPointsUrl,
          layerName: tableName,
          pane: 'pane-points',
          style: function() {
            return {
              color: CONFIG.pointStroke,
              weight: CONFIG.pointStrokeWidth,
              opacity: CONFIG.pointStrokeOpacity
            };
          },
          pointToLayer: (feature, latlng) => {
            const p = getProbAsPercent(feature.properties);
            const marker = L.circleMarker(latlng, {
              radius: CONFIG.pointBaseRadius,
              weight: CONFIG.pointStrokeWidth,
              opacity: CONFIG.pointStrokeOpacity,
              color: CONFIG.pointStroke,
              fillOpacity: 0.85,
              fillColor: colorForPercent(p),
              className: 'wf-point'
            });
            marker.options.color = CONFIG.pointStroke;
            return marker;
          },
          onEachFeature: (feature, lyr) => {
            const p = getProbAsPercent(feature.properties);
            feature.properties.probability = p;
            allPoints.push({ probability: p });

            // Hover effects
            lyr.on('mouseover', function() {
              this.setStyle({ 
                radius: CONFIG.pointHoverRadius,
                weight: CONFIG.pointStrokeWidth + 0.5,
                color: '#2c3e50'
              });
              this.bringToFront();
            });
            lyr.on('mouseout', function() {
              this.setStyle({ 
                radius: CONFIG.pointBaseRadius,
                weight: CONFIG.pointStrokeWidth,
                color: CONFIG.pointStroke
              });
            });
            lyr.on('click', (ev) => handleWaterfallClick(feature, ev));

            // Tooltip („Éá„Çπ„ÇØ„Éà„ÉÉ„Éó„ÅÆ„Åø)
            if (!CONFIG.isMobile) {
              const txt = (p==null) ? '‚Äî' : (p.toFixed(1) + '%');
              lyr.bindTooltip(`Probability: ${txt}`, {
                permanent: false,
                direction: 'top',
                offset: [0, -10]
              });
            }
          }
        }).addTo(map);

        pointsLayer = layer;
        const displayName = prettyName(tableName);
        overlayLayers[displayName] = layer;
        layersControl.addOverlay(layer, displayName);
      }
      gpkgPts.close();

      // ÂàùÊúüÁµ±Ë®à
      updateStatistics(allPoints);

      // È´òÁ¢∫ÁéáÔºà>60%Ôºâ„ÅÆËªΩ„ÅÑ„Éè„Ç§„É©„Ç§„ÉàÔºà„Éá„Çπ„ÇØ„Éà„ÉÉ„Éó„ÅÆ„ÅøÔºâ
      function addHighProbabilityHighlight() {
        if (CONFIG.isMobile || !pointsLayer) return;
        pointsLayer.eachLayer(function(layer) {
          const prob = layer.feature?.properties?.probability;
          if (prob > 80 && layer._path) {
            layer._path.style.animation = 'pulse 2s infinite';
          }
        });
      }
      const style = document.createElement('style');
      style.textContent = `
        @keyframes pulse {
          0% { transform: scale(1); opacity: 0.9; }
          50% { transform: scale(1.1); opacity: 1; }
          100% { transform: scale(1); opacity: 0.9; }
        }
      `;
      document.head.appendChild(style);
      setTimeout(addHighProbabilityHighlight, 500);

      // ===== Legend =====
      const legend = L.control({ position: 'bottomright' });
      legend.onAdd = function() {
        const div = L.DomUtil.create('div', 'wf-legend leaflet-control');
        const items = Object.entries({
          [COLOR_SCHEME.below10]: '< 10%',
          [COLOR_SCHEME.range10_20]: '10‚Äì20%',
          [COLOR_SCHEME.range20_30]: '20‚Äì30%',
          [COLOR_SCHEME.range30_40]: '30‚Äì40%',
          [COLOR_SCHEME.range40_50]: '40‚Äì50%',
          [COLOR_SCHEME.range50_60]: '50‚Äì60%',
          [COLOR_SCHEME.range60_70]: '60‚Äì70%',
          [COLOR_SCHEME.range70_80]: '70‚Äì80%',
          [COLOR_SCHEME.above80]: '> 80%'
        }).map(([color, label]) => 
          `<div class="item">
            <span class="swatch" style="background:${color}"></span>
            <span>${label}</span>
          </div>`
        ).join('');
        div.innerHTML = `
          <div class="hdr">
            <span>Habitat Suitability</span>
            <button class="minimize-btn" title="Minimize">‚àí</button>
          </div>
          <div class="body">
            ${items}
            <div style="margin-top: 8px; padding-top: 6px; border-top: 1px solid #e1e4e8; font-size: 10px; color: #5a6c7d;">
              <strong>Threshold:</strong> >60% = High suitability
            </div>
          </div>
        `;
        L.DomEvent.disableClickPropagation(div);
        return div;
      };
      legend.addTo(map);
      const lg = legend.getContainer();
      const lgMinBtn = lg.querySelector('.minimize-btn');
      lgMinBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        lg.classList.toggle('is-minimized');
        lgMinBtn.innerHTML = lg.classList.contains('is-minimized') ? '+' : '‚àí';
      });

      // ===== Inset Beeswarm =====
      const inset = L.control({ position: 'bottomleft' });
      inset.onAdd = function() {
        const div = L.DomUtil.create('div', 'wf-inset leaflet-control');
        div.innerHTML = `
          <img class="is-beeswarm" src="data/beeswarm_RF.png" alt="SHAP Beeswarm Plot"/>
          <div class="cap">SHAP Global Feature Importance (RF)</div>
        `;
        L.DomEvent.disableClickPropagation(div);
        return div;
      };
      inset.addTo(map);

      // ===== Data Export Button (ÊüªË™≠ËÄÖÂêë„Åë„ÄÅ„Éá„Çπ„ÇØ„Éà„ÉÉ„Éó„ÅÆ„Åø) =====
      if (!CONFIG.isMobile) {
        const exportBtn = L.control({ position: 'bottomright' });
        exportBtn.onAdd = function() {
          const div = L.DomUtil.create('div', 'export-btn leaflet-control');
          div.innerHTML = `
            <button id="exportData" title="Export visible points as CSV">
              <span>üìä</span> Export Data
            </button>
          `;
          L.DomEvent.disableClickPropagation(div);
          return div;
        };
        exportBtn.addTo(map);

        setTimeout(() => {
          const btn = document.getElementById('exportData');
          if (btn) btn.addEventListener('click', exportVisiblePoints);
        }, 100);
      }
      function exportVisiblePoints() {
        if (!pointsLayer) return;
        let csv = 'ID,Latitude,Longitude,Probability(%)\n';
        let count = 0;
        pointsLayer.eachLayer(function(layer) {
          const prob = layer.feature?.properties?.probability;
          if (prob >= currentMinProb && prob <= currentMaxProb) {
            const id = layer.feature.properties.ID
                   ?? layer.feature.properties.id
                   ?? count;
            const latlng = layer.getLatLng();
            csv += `${id},${latlng.lat.toFixed(6)},${latlng.lng.toFixed(6)},${prob.toFixed(2)}\n`;
            count++;
          }
        });
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `sasakia_charonda_habitat_${new Date().toISOString().split('T')[0]}.csv`;
        a.click();
        window.URL.revokeObjectURL(url);
        alert(`Exported ${count} points to CSV`);
      }

      // ===== Key Findings Panel (ÊüªË™≠ËÄÖÂêë„Åë„ÄÅ„Éá„Çπ„ÇØ„Éà„ÉÉ„Éó„ÅÆ„Åø) =====
      if (!CONFIG.isMobile) {
        const keyFindings = L.control({ position: 'topleft' });
        keyFindings.onAdd = function() {
          const div = L.DomUtil.create('div', 'key-findings leaflet-control');
          div.innerHTML = `
            <h5>Key Findings</h5>
            <ol>
              <li><strong>Primary determinants</strong>: overwintering microclimate, host tree maturity, and forest floor cover (Global SHAP).</li>
              <li><strong>Model performance</strong>: <strong>Random Forest</strong> achieved optimal performance (AUC of 0.720).</li>
              <li><strong>Univariate SHAP</strong>
                <ul>
                  <li>Litter depth ‚â• 5 cm</li>
                  <li>Diameter at breast height (DBH) for <em>Celtis sinensis</em> ‚â• 40 cm</li>
                  <li>Vegetation cover ‚â• 40%</li>
                </ul>
              </li>
            </ol>
          `;
          L.DomEvent.disableClickPropagation(div);
          return div;
        };
        setTimeout(() => keyFindings.addTo(map), 1000);
      }

      // ===== Mobile tweaks =====
      if (CONFIG.isMobile) {
        CONFIG.pointBaseRadius = 8;
        CONFIG.pointHoverRadius = 10;
        map.options.tap = true;
        map.options.tapTolerance = 40;
      }

    })().catch((err) => {
      console.error('Initialization error:', err);
      alert('Failed to initialize the map viewer.\n' + err.message);
    });
  </script>
</body>
</html>




